<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-02-26 Sun 23:37 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>HTCondor@IAC User's Manual</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Ángel de Vicente" />
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2017 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">HTCondor@IAC User's Manual</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#org98666ee">1. Introduction</a>
<ul>
<li><a href="#org8bf61b3">1.1. What is HTCondor?</a></li>
<li><a href="#orgfa4a5a3">1.2. How can HTCondor help me?</a></li>
<li><a href="#org37cfec5">1.3. How <b>powerful</b> is HTCondor?</a></li>
<li><a href="#orgdf12944">1.4. Which machines are part of HTCondor?</a></li>
<li><a href="#org591d1ea">1.5. How can I use HTCondor?</a></li>
<li><a href="#org5b9be45">1.6. Where will my application run?</a></li>
<li><a href="#org2e77735">1.7. Acknowledging HTCondor in publications</a></li>
<li><a href="#orgf7c9e98">1.8. Further information, support</a></li>
</ul>
</li>
<li><a href="#orgcaa56c2">2. Main HTCondor commands</a>
<ul>
<li><a href="#org7858b3c">2.1. Checking pool status</a></li>
<li><a href="#org55d464f">2.2. Submitting jobs</a></li>
<li><a href="#orga2370c8">2.3. Checking and managing submitted jobs</a></li>
<li><a href="#org7441334">2.4. Getting info from logs</a></li>
<li><a href="#orgbccdd65">2.5. Other commands</a></li>
</ul>
</li>
<li><a href="#orgae017a3">3. Submit files (TBD)</a>
<ul>
<li><a href="#org1d51386">3.1. Introduction</a></li>
<li><a href="#orgf3f95f8">3.2. Creating a Submit File</a>
<ul>
<li><a href="#org6d57350">3.2.1. Comments</a></li>
<li><a href="#orgc12ba43">3.2.2. Variables and macros</a></li>
<li><a href="#org66cfeff">3.2.3. Submit commands</a></li>
</ul>
</li>
<li><a href="#orgb218d73">3.3. Templates and examples</a>
<ul>
<li><a href="#orga2bf2e2">3.3.1. Common Template</a></li>
<li><a href="#orgf58eb5b">3.3.2. Examples when working with input/output files and arguments</a>
<ul>
<li><a href="#org9c8f778">3.3.2.1. <b>Example A</b> (arbitrary filenames)</a></li>
<li><a href="#orgb5a73e5">3.3.2.2. <b>Example B</b> (based on ProcessID, old system before HTCondor v8.4.0)</a></li>
<li><a href="#org7628438">3.3.2.3. <b>Example C</b> (lists of files and arguments written in submit file)</a></li>
<li><a href="#org3e86b09">3.3.2.4. Example D (lists of files and arguments in external file)</a></li>
<li><a href="#org49f8a2c">3.3.2.5. Example E (<code>stdin</code>, <code>initialdir</code> external scripts and lists)</a></li>
<li><a href="#org9cecac2">3.3.2.6. Example F (loops)</a></li>
<li><a href="#org976ca67">3.3.2.7. Example G</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div class="mdframed">
<div class="warning">
<p>
If you have no experience with HTCondor, we recommend that you contact us before
running any job so we can give you a quick introduction (bear in mind that you
will be using other users' computers and there are some basic guidelines that
you must follow to avoid disturbing them).
</p>

</div>

</div>

<div class="mdframed">
<div class="note">
<p>
The HTCondor infrastructure at the IAC has been recently expanded and improved,
with about 100 new Linux desktop PCs financed by the Ministry of Economy and
Competitiveness through FEDER funds, code IACA13-3E-2493. 
</p>

</div>

</div>

<div id="outline-container-org98666ee" class="outline-2">
<h2 id="org98666ee"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-org8bf61b3" class="outline-3">
<h3 id="org8bf61b3"><span class="section-number-3">1.1</span> What is HTCondor?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
At the IAC we have several <a href="http://research.iac.es/sieinvens/SINFIN/Main/supercomputing.php">Supercomputing</a> resources that allow you to obtain
your computational results in much less time and/or work with much more complex
problems. One of them is <a href="http://research.cs.wisc.edu/htcondor/">HTCondor</a>, a High Throughput Computing (<a href="http://en.wikipedia.org/wiki/High-throughput_computing">HTC</a>) system. The
underlying idea is quite simple (and powerful): let's use idle machines to
perform computations while their owners are away. So, in a nutshell, HTCondor is
an application that is installed in our PCs to make it possible to run a large
number of yours and others' computations at a time in different machines when
they are not being used, achieving a better utilization of our resources. A more
detailed overview of HTCondor is available at the <a href="https://htcondor.readthedocs.io/en/v10_0/overview/index.html">official documentation</a>.
</p>
</div>
</div>

<div id="outline-container-orgfa4a5a3" class="outline-3">
<h3 id="orgfa4a5a3"><span class="section-number-3">1.2</span> How can HTCondor help me?</h3>
<div class="outline-text-3" id="text-1-2">
<p>
HTCondor is very useful when you have an application that has to run a large
number of times over different input data. For instance, suppose you have a
program that carry out some calculations taking an image file as input. Let's
say that the processing time is about one hour per image and you want to process
250 images. Then you can use your own machine and process all images one by one,
and wait more than 10 days to get all results, or you can use HTCondor to
process each image in different computers and hopefully get all results in one
hour, or maybe two or four, but for sure less than 10 days. And HTCondor will do
all the work for you: it will copy the input files to the remote machines,
execute your program there with different inputs and bring back the results to
your machine when they are complete.
</p>
</div>
</div>

<div id="outline-container-org37cfec5" class="outline-3">
<h3 id="org37cfec5"><span class="section-number-3">1.3</span> How <b>powerful</b> is HTCondor?</h3>
<div class="outline-text-3" id="text-1-3">
<p>
HTCondor calls a <i>slot</i> the unit that executes a job, typically a CPU or a core
if the CPU has several of them. Right now we have over 1000 slots that might
execute applications submitted via HTCondor. It means that everyday more than
24000 hours could be available to run HTCondor jobs, close to 3 years of
computation in a single day! Obviously, this is the theoretical maximum if no
one were using their computers and all slots were idle, but the number of actual
available slots could be around 400 during office hours and around 700 at nights
and weekends.
</p>

<p>
You can see real-time HTCondor@IAC statistics (global and per user) <a href="http://pasa/ganglia/?r=week&amp;cs=&amp;ce=&amp;m=load_one&amp;tab=v&amp;vn=pool_usage&amp;hide-hf=false">here</a>. Figure
<a href="#org37a8baf">1</a> is an example showing the global usage where <i>Owner</i> represents
<i>slots</i> that are being used outside of HTCondor. The remaining <i>slots</i> are
available to HTCondor, but if there are no eligible jobs to run, those slots
will be in <i>CPUsNotInUse</i> state. Those <i>slots</i> that are actually being used by
HTCondor are those in the <i>CPUsInUse</i> state.
</p>


<div id="org37a8baf" class="figure">
<p><img src="images/introduction/weekly_usage.png" alt="weekly_usage.png" />
</p>
<p><span class="figure-number">Figure 1: </span>Weekly global usage</p>
</div>
</div>
</div>

<div id="outline-container-orgdf12944" class="outline-3">
<h3 id="orgdf12944"><span class="section-number-3">1.4</span> Which machines are part of HTCondor?</h3>
<div class="outline-text-3" id="text-1-4">
<p>
HTCondor is installed in a number of <i>burros</i> (High Performance Linux PCs) and
desktop PCs at the IAC Headquarters in La Laguna. 
</p>

<p>
Regarding their hardware specifications, they are rather heterogeneous and their
availability and specifications change from time to time. You can check which
machines make up the HTCondor@IAC pool at any given time in the <a href="http://pasa/ganglia/?r=week&amp;cs=&amp;ce=&amp;c=IAC+HTCondor&amp;h=&amp;tab=m&amp;vn=&amp;hide-hf=false&amp;m=cpu_num&amp;sh=1&amp;z=small&amp;hc=4&amp;host_regex=&amp;max_graphs=0&amp;s=by+name">HTCondor Ganglia
webpage</a>. 
</p>

<p>
Regarding their software specifications, at present all machines are running
Ubuntu 18.04 and the installed software should be also more or less the same in
every machine (see the <a href="http://research.iac.es/sieinvens/SINFIN/Main/software_sinfin.php">software supported by the SIE</a>), which makes it easy to
run almost every application in any machine.
</p>

<p>
Detailed information about each machine can be obtained with the command
<code>condor_status</code> (see Section <a href="#org7858b3c">2.1</a>). 
</p>

<p>
HTCondor provides a simple mechanism by which you can specify a set of
requirements for the machines where you want your application to run, for
example: memory per slot, OS version, etc. (see Section <a href="#orgae017a3">3</a>).
</p>
</div>
</div>

<div id="outline-container-org591d1ea" class="outline-3">
<h3 id="org591d1ea"><span class="section-number-3">1.5</span> How can I use HTCondor?</h3>
<div class="outline-text-3" id="text-1-5">
<p>
If you have an account in the IAC network, then you can use HTCondor. 
</p>

<p>
HTCondor is a batch-processing system (i.e. non-interactive), so you submit jobs
to the HTCondor queue with the <code>condor_submit</code> command, and providing a text
submission file, where you specify the executable file, its arguments, inputs
and outputs, etc. (see Section <a href="#org55d464f">2.2</a>).
</p>

<p>
You do not need to prepare or compile your programs in any special way to run
them, and almost all programming languages should be suitable (shell scripts,
Python, Perl, C, Fortran, IDL, etc.). Sometimes a few minor modifications may be
needed in order to specify arguments and the locations of inputs or outputs.
</p>
</div>
</div>

<div id="outline-container-org5b9be45" class="outline-3">
<h3 id="org5b9be45"><span class="section-number-3">1.6</span> Where will my application run?</h3>
<div class="outline-text-3" id="text-1-6">
<p>
When you submit jobs to the HTCondor queue, HTCondor uses its allocation
algorithm to send and execute your jobs on those idle slots that satisfy your
requirements. Idle slots are those located in machines where there has been no
keyboard/mouse activity for a long time and the computer load is low enough to
ensure that there is no interference with the owner's processes. 
</p>

<p>
While HTCondor is running its jobs, it also keeps checking that the owner is not
using the machine. If HTCondor detects any activity in the computer (for
instance, keyboard activity), then it will suspend all its jobs and wait a
little while to see whether the machine gets idle again so as to resume the
jobs. If the machine does not become idle in a short time, HTCondor will
<i>vacate</i> it, interrupting all HTCondor jobs and sending them to other available
slots in any other idle machine. 
</p>

<p>
HTCondor will repeat this process untill all jobs are done, optionally sending
notifications via email when they are finished or if any errors show up.
</p>
</div>
</div>

<div id="outline-container-org2e77735" class="outline-3">
<h3 id="org2e77735"><span class="section-number-3">1.7</span> Acknowledging HTCondor in publications</h3>
<div class="outline-text-3" id="text-1-7">
<p>
It is important that you acknowledge HTCondor in any publication of your work
where you have used HTCondor (and we would be grateful if you could send us the
details of the published paper). This will help us to improve the visibility of
the HTCondor@IAC facility and ensure that it is available at the IAC for the
foreseable future. Although there is no standard acknowledgment format, we
suggest the following:
</p>

<pre class="example">
This paper made use of the IAC Supercomputing facility HTCondor
(http://research.cs.wisc.edu/htcondor/), partly financed by the Ministry of
Economy and Competitiveness with FEDER funds, code IACA13-3E-2493.
</pre>
</div>
</div>

<div id="outline-container-orgf7c9e98" class="outline-3">
<h3 id="orgf7c9e98"><span class="section-number-3">1.8</span> Further information, support</h3>
<div class="outline-text-3" id="text-1-8">
<p>
This manual is only a brief introduction to all HTCondor has to offer. For
detailed and complete information, check the official <a href="https://htcondor.readthedocs.io/en/v10_0/">HTCondor v10.0 Manual</a>.
</p>

<p>
If you need help or you are having any kind of issues related to HTCondor,
the SIE gives direct support to IAC's users who want to use HTCondor: we
will not code your whole application, but we will help and advise you on how to
get the most out of HTCondor. 
</p>

<p>
If you want to stay informed about HTCondor@IAC updates, tips, etc. there is a
low traffic mailing list (send us an e-mail if you want to be subscribed to it).
</p>
</div>
</div>
</div>


<div id="outline-container-orgcaa56c2" class="outline-2">
<h2 id="orgcaa56c2"><span class="section-number-2">2</span> Main HTCondor commands</h2>
<div class="outline-text-2" id="text-2">
<p>
HTCondor has ~100 commands (see the <a href="https://htcondor.readthedocs.io/en/v10_0/man-pages/index.html">Command Reference Manual)</a>, but you will only
need a few of them for most of you work with HTCondor. In this section we
introduce the most common ones, grouped according to the four common tasks:
Checking pool status (<a href="#org7858b3c">2.1</a>), Submitting jobs (<a href="#org55d464f">2.2</a>), Checking and managing submitted jobs (<a href="#orga2370c8">2.3</a>) and Getting info from logs (<a href="#org7441334">2.4</a>). For each command we
also give a list of some of their most useful options (but note that you can
also get full details about each command by executing <code>man condor_&lt;cmd&gt;</code> in your
shell).
</p>
</div>

<div id="outline-container-org7858b3c" class="outline-3">
<h3 id="org7858b3c"><span class="section-number-3">2.1</span> Checking pool status</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li><code>condor_status</code> list slots in the HTCondor pool and their status: <code>Owner</code> (used
by owner), <code>Claimed</code> (used by HTCondor), <code>Unclaimed</code> (available to be used
by HTCondor), etc. 
<ul class="org-ul">
<li><code>-avail</code> List those slots that are not busy and could run HTCondor jobs at
this moment</li>
<li><code>-submitters</code> Show information about the current general status, like
number of running, idle and held jobs (and submitters)</li>
<li><code>-run</code> List slots that are currently running jobs and show related
information (owner of each job, machine where it was submitted from, etc.)</li>
<li><code>-compact</code> Compact list, with one line per machine instead of per slot</li>
<li><code>-state -total</code> List a summary according to the state of each slot</li>
<li><code>-master</code> List machines, but just their names (status and slots are not
shown)</li>
<li><code>-server</code> List attributes of slots, such as memory, disk, load, flops, etc.</li>
<li><code>-sort Memory</code> Sort slots by Memory, you can try also with other attributes</li>
<li><code>-af &lt;attr1&gt; &lt;attr2&gt; &lt;...&gt;</code> List specific attributes of slots, using
autoformat (new version, very powerful)</li>
<li><code>-format &lt;fmt&gt; &lt;attr&gt;</code> List attributes using the specified format (old
version). For instance, next command will show the name of each slot and the
disk space: <code>condor_status -format "%s\t " Name -format "%d KB\n" Disk</code></li>
<li><code>&lt;machine&gt;</code> Show the status of a specific machine</li>
<li><code>&lt;machine&gt; -long</code> Show the complete "ClassAd" of a machine (its
specifications). We can use these specifications to add restrictions in the
submit file so we can control which machines we want to use.</li>
<li><code>-constraint &lt;constraint&gt;</code> Only Show slots that satisfy the
constraint. I.e: <code>condor_status -constraint 'Memory &gt; 1536'</code> will only show
slots with more than 1.5GB of RAM per slot.</li>
</ul></li>
</ul>
</div>
</div>

<div id="outline-container-org55d464f" class="outline-3">
<h3 id="org55d464f"><span class="section-number-3">2.2</span> Submitting jobs</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li><p>
<code>condor_submit &lt;submit_file&gt;</code>: Submit jobs to the HTCondor queue according to
the information specified in <code>submit_file</code>. Visit the <b>submit file page</b> to
see some examples of these files. There are also some FAQs related to the
submit file. Useful options:
</p>

<ul class="org-ul">
<li>=-dry-run &lt;dest<sub>file</sub>&gt; =: this option parses the submit file and saves all the</li>
</ul>
<p>
related info (name and locations of input and output files after expanding all
variables, value of requirements, etc.) to <code>&lt;dest_file&gt;</code>, but jobs are '''not'''
submitted. Using this option is highly recommended when debugging or before the
actual submission if you have made some modifications in your submit file and
you are not sure whether they will work.
</p>

<ul class="org-ul">
<li><code>'var=value'</code>: add or modify variable(s) at submission time, without changing</li>
</ul>
<p>
the submit file. For instance, if you are using <code>queue $(N)</code> in your submit
file, then <code>condor_submit &lt;submit_file&gt; 'N = 10'</code> will submit 10 jobs. You can
specify several pairs of <code>var=value</code>.
</p>

<ul class="org-ul">
<li><code>-append &lt;command&gt;</code>: add submit commands at submission time, without changing</li>
</ul>
<p>
the submit file. You can add more than one command using several times
<code>-append</code>.
</p></li>
</ul>

<p>
When submitted, each job is identified by a pair of numbers '''X.Y''', like
345.32. The first number (X) is the '''cluster id''': every submission gets a
different cluster id, that is shared by all jobs belonging to the same
submission. The second number (Y) is the '''process id''': if you submitted N
jobs, then this id will go from 0 for the first job to N-1 for the last one. For
instance, if you submit a file specifying 4 jobs and HTCondor assign id 523 to
that cluster, then the ids of your jobs will be 523.0, 523.1, 523.2 and 523.3
(you can get these ids and more info using <code>condor_q</code> command).
</p>

<div class="mdframed">
<p>
<b>Caution!</b>: Before submitting your jobs, always do some simple tests in
order to make sure that both your submit file and program work in a proper way:
if you are going to submit hundreds of jobs and each job takes several hours to
finish, before doing that try with just a few jobs and change the input data in
order to let them finish in minutes. Then check the results to see if everything
went fine before submitting the real jobs. Bear in mind that submitting untested
files and/or jobs may cause a waste of time and resources if they fail, and also
your priority will be lower in following submissions. 
</p>

</div>
</div>
</div>


<div id="outline-container-orga2370c8" class="outline-3">
<h3 id="orga2370c8"><span class="section-number-3">2.3</span> Checking and managing submitted jobs</h3>
<div class="outline-text-3" id="text-2-3">
<div class="mdframed">
<p>
<b>Note:</b> Each machine manages its own HTCondor queue, so it has information only
about those jobs that were submitted on it (and no information about any other
jobs you may have submitted on other machines). Most of the commands explained
in this section get information asking only the local queue, which means that
you will only see those jobs that you have submitted on that specific
machine. If you submit jobs from different machines, and later you want to
check, hold, release, remove, etc. those jobs, you may need to connect to each
one of those machines where you have submitted jobs from, or, when possible, use
the commands with extra options to communicate with other machines.
</p>

</div>


<ul class="org-ul">
<li><code>condor_q</code>: Show my jobs that have been submitted in this machine. By default</li>
</ul>
<p>
you will see the ID of the job(<code>clusterID.processID</code>), the owner, submitting
time, run time, status, priority, size and command. [*STATUS*: <b>I</b>:idle (waiting
for a machine to execute on); <b>R</b>: running; <b>H</b>: on hold (there was an error,
waiting for user's action); <b>S</b>: suspended; <b>C</b>: completed; <b>X</b>: removed; <b>&lt;</b>:
transferring input; and <b>&gt;</b>: transferring output]. Useful options:
</p>
<ul class="org-ul">
<li><code>-global</code>: Show my jobs submitted in any machine, not only the current one</li>
<li><code>-nobatch</code>: Starting in version HTCondor 8.6.0 installed in January 2017,
data is displayed in a compact mode (one line per cluster). With this option
output will be displayed in the old format (one line per process)</li>
<li><code>-wide</code>: Do not truncate long lines. You can also use <code>-wide:&lt;n&gt;</code> to
truncate lines to fit <code>n</code> columns</li>
<li><code>-analyze &lt;job_id&gt;</code>: Analyse a specific job and show the reason why it is in
its current state (useful for those jobs in Idle status: Condor will show us
how many slots match our restrictions and may give us suggestion)</li>
<li><code>-better-analyze &lt;job_id&gt;</code>: Analyse a specific job and show the reason why
it is in its current state, giving extended info</li>
<li><code>-long &lt;job_id&gt;</code>: Show all information related to that job</li>
<li><code>-run</code>: Show your running jobs and related info, like how much time they
have been running, in which machine, etc.</li>
<li><code>-currentrun</code>: Show the consumed time on the current run, the cumulative
time from last executions will not be used (you can combine also with <code>-run</code>
flag to see only the running processes at the moment)</li>
<li><code>-hold</code>: Show only jobs in the "on hold" state and the reason for that. Held
jobs are those that got an error so they could not finish. An action from
the user is expected to solve the problem, and then he should use the
<code>condor_release</code> command in order to check the job again</li>
<li><code>-af &lt;attr1&gt; &lt;attr2&gt; &lt;...&gt;</code>: List specific attributes of jobs, using
autoformat</li>
<li>[-{-<code>''-global -submitter &lt;user&gt;</code>-}: Show all jobs from user <code>&lt;user&gt;</code> in all
machines. <b>Note</b>: starting in HTCondor version 8.6.0 installed at IAC in
January 2017, HTCondor will NOT show other users' jobs'' by default, but you
can use some flags like <code>-allusers</code> to change this behaviour -]</li>
</ul>


<ul class="org-ul">
<li><code>*condor_tail* &lt;job_id&gt;</code>: Display on screen the last lines of the <code>stdout</code>
(screen) of a running job on a remote machine. You can use this command to
check whether your job is working fine, you can also visualize errors
(<code>stderr</code>) or output files created by your program (see also
CondorFAQs#ssh). Useful options:
<ul class="org-ul">
<li><code>-f</code>: Do not stop displaying the content, it will be displayed until
interrupted with <code>Ctrl+C</code></li>
<li><code>-no-stdout -stderr</code>: Show the content of <code>stderr</code> instead of <code>stdout</code></li>
<li><code>-no-stdout &lt;output_file&gt;</code>: Show the content of an output file (<code>output_file</code>
has to be listed in the <code>transfer_output_files</code> command in the submit file).</li>
</ul></li>

<li><p>
<code>*condor_release* &lt;job_id&gt;</code>: Release a specific held job in the queue. Useful options:
</p>
<ul class="org-ul">
<li><code>&lt;cluster_id&gt;</code>: Instead of giving a <code>&lt;job_id&gt;</code>, you can specify just the
<code>&lt;cluster_id&gt;</code> in order to release all held jobs of a specific submission</li>
<li><code>-constraint &lt;constraint&gt;</code>: Release all my held jobs that satisfy the
constraint</li>
<li><code>-all</code>: Release all my held jobs</li>
<li><b>Note:</b> Jobs with ''on hold'' state are those that HTCondor was not able</li>
</ul>
<p>
to properly execute, usually due to problems with executable, paths, etc. If
you can solve the problems changing the input files and/or the executable,
then you can use <code>condor_release</code> command to run again your program since it
will send again all files to the remote machines. If you need to change the
submit file to solve the problems, then <code>condor_release</code> will NOT work because
it will not evaluate again the submit file. In that case you can use
<code>condor_qedit</code> (see the HOWTOs.CondorFAQs#ch<sub>submit</sub>) or cancel all
held jobs and re-submit them again-]
</p></li>

<li><code>*condor_hold* &lt;job_id&gt;</code>: Put jobs into the hold state. It could be useful
when you detect that there are some problems with your input data (see
CondorFAQs#bad<sub>inputs</sub> for more info), you are running out of disk space for
outputs, etc. With this command you can delay the execution of your jobs
holding them, and, after solving the problems, assign them the idle status
using <code>condor_release</code>, so they will be executed again. Useful options:
<ul class="org-ul">
<li><code>&lt;cluster_id&gt;</code>: Instead of giving a <code>&lt;job_id&gt;</code>, you can specify just the
<code>&lt;cluster_id&gt;</code> in order to hold all jobs of a specific submission</li>
<li><code>-constraint &lt;constraint&gt;</code>: Hold all jobs that satisfy the constraint</li>
<li><code>-all</code>: Hold all my jobs from the queue</li>
</ul></li>

<li><code>*condor_rm* &lt;job_id&gt;</code>: Remove a specific job from the queue (it will be
removed even if it is running). Jobs are only removed from the current
machine, so if you submitted jobs from different machines, you need to remove
your jobs from each of them. Useful options:
<ul class="org-ul">
<li><code>&lt;cluster_id&gt;</code>: Instead of giving a <code>&lt;job_id&gt;</code>, you can specify just the
<code>&lt;cluster_id&gt;</code> in order to remove all jobs of a specific submission</li>
<li><code>-constraint &lt;constraint&gt;</code>: Remove all jobs that satisfy the constraint</li>
<li><code>-all</code>: Remove all my jobs from the queue</li>
<li><code>-forcex &lt;job_id&gt;</code>: It could happen that after removing jobs, they don't
disappear from the queue as expected, but they just change status to
<b>X</b>. That's normal since HTCondor may need to do some extra operations. If
jobs stay with 'X' status a very long time, you can force their elimination
adding <code>-forcex</code> option. For instance: <code>condor_rm -forcex -all</code>.</li>
</ul></li>

<li><code>*condor_prio*</code>: Set the priority of my jobs. A user can only change the
priority of her own jobs, to specify which ones she would like to run first
(the higher the number, the bigger the priority). Priority could be absolute
or relative, use <code>man condor_prio</code> for further information</li>

<li><code>*condor_ssh_to_job &lt;job_id&gt;*</code>: Create an ssh session to a running job in a
remote machine. You can use this command to check whether the execution is
going fine, download/upload inputs or outputs, etc. More information about
this command is available in CondorFAQs#ssh.</li>
</ul>
</div>
</div>

<div id="outline-container-org7441334" class="outline-3">
<h3 id="org7441334"><span class="section-number-3">2.4</span> Getting info from logs</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li><code>*condor_userlog* &lt;file.log&gt;</code>: Show and summarize job statistics from the job
log files (those created when using <code>log</code> command in the submit file)</li>

<li><code>*condor_history*</code>: Show all completed jobs to date (it has to be run in the
{<del>same machine</del>} where the submission was done). Useful options:
<ul class="org-ul">
<li><code>-userlog &lt;file.log&gt;</code>: list basic information registered in the log files (use
<code>condor_logview &lt;file.log&gt;</code> to see information in graphic mode)</li>
<li><code>-long XXX.YYY -af LastRemoteHost</code>: show machine where job XXX.YYY was
executed</li>
<li><code>-constraint &lt;constraint&gt;</code>: Only show jobs that satisfy the constraint. I.e:
<code>condor_history -constraint 'RemoveReason</code>!=UNDEFINED'=: show your jobs that
were removed before completion</li>
</ul></li>

<li><code>condor_logview &lt;file.log&gt;</code>: This is not an original HTCondor command, we have
created this link to the script that allows you to display graphical
information contained in the log of your executions.</li>

<li>There is also an online tool to analyze your log files and get more
information: <code>HTCondor Log Analyzer</code> (<a href="http://condorlog.cse.nd.edu/">http://condorlog.cse.nd.edu/</a>).</li>
</ul>
</div>
</div>

<div id="outline-container-orgbccdd65" class="outline-3">
<h3 id="orgbccdd65"><span class="section-number-3">2.5</span> Other commands</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li><code>condor_userprio</code>: Show active HTCondor users' priority. Lower values means
higher priority where 0.5 is the highest. Use <code>condor_userprio -allusers</code> to
see all users' priority, you can also add flags <code>-priority</code> and/or <code>-usage</code> to
get detailed information</li>
<li><code>condor_qedit</code>: use this command to modify the attributes of a job placed on
the queue. This may be useful when you need to change some of the parameters
specified in the submit file without re-submitting jobs (see
HOWTOs.CondorFAQs#ch<sub>submit</sub>).</li>
<li><code>condor_submit_dag &lt;dag_file&gt;</code>: Submit a DAG file, used to describe jobs
with dependencies. Visit the CondorHowTo#howto<sub>dagman</sub> section for more info
and examples.</li>
<li><code>condor_version</code>: Print the version of HTCondor.</li>
<li>If you want some general information about HTCondor queue, the pool of
machines, where jobs have been executed on, etc., you can try our online stats
about HTCondor: <a href="http://carlota:81/condor_stats/">http://carlota:81/condor_stats/</a> and <a href="http://nectarino/">http://nectarino/</a>.</li>
</ul>
</div>
</div>
</div>


<div id="outline-container-orgae017a3" class="outline-2">
<h2 id="orgae017a3"><span class="section-number-2">3</span> Submit files (TBD)</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-org1d51386" class="outline-3">
<h3 id="org1d51386"><span class="section-number-3">3.1</span> Introduction</h3>
<div class="outline-text-3" id="text-3-1">
<p>
To execute your application with HTCondor, you have to specify some parameters
like the name of your executable, its arguments, inputs and outputs,
requirements, etc. This information is written in a plain text using <b>submit
commands</b> in a file called ''HTCondor Submit Description File'' or simply
<b>submit file</b>. Once that file is filled with all needed info, you have to submit
it to HTCondor using <code>*condor_submit*</code> in your terminal, and then it will be
processed and your jobs will be added to the queue in order to be executed.
</p>

<p>
<b>Submit files have considerably changed after the release of versions 8.4.X</b>
(first version 8.4.0 released in Sept 2015, since Feb 2017 we are using versions
8.6.X). Some operations were not possible or highly painful in previous versions
(like dealing with an undetermined number of files with arbitrary names,
declaring variables and macros and performing operations with them, including
submission commands from other files, adding conditional statements, etc.). To
solve that, many researchers developed external scripts (perl, python, bash,
etc.) to dynamically create description files and submit them, what in most
cases resulted in complex submissions and less efficient executions, not to
mention that usually it was needed a hard work to adapt those scripts when the
application, arguments and/or IO files changed.
</p>

<p>
With the addition of <a href="http://research.cs.wisc.edu/htcondor/manual/v8.6/2_5Submitting_Job.html#SECTION00352000000000000000">new, powerful and flexible commands</a> most of those problems
have been solved, so there should be no need of using external scripts and *we
highly recommend you always use a HTCondor submit description file instead of
developing scripts in other languages*. If you did that in the past, please,
consider migrating your old scripts, we will give you support if you find any
problems.
</p>

<p>
In this section you will find templates and examples of HTCondor Submit
Description Files. Use them as reference to create your own submit files and
contact us if you have any doubt or issue. Topics:
</p>

<ul class="org-ul">
<li>Creating a submit file (description and structure of
submit files: comments, variables, commands, etc.)</li>
<li>Templates and examples of submit files</li>
<li>OLD examples</li>
<li>Some more useful commands and info</li>
</ul>


<div class="mdframed">
<p>
<b>Caution!: Before submitting your real jobs, perform always some simple tests</b>
 in order to make sure that both your submit file and program will work in a
 proper way: if you are going to submit hundreds of jobs and each job takes
 several hours to finish, before doing that try with just a few jobs and change
 the input data in order to let them finish in minutes. Then check the results
 to see if everything went fine before submitting the real jobs. Also we
 recommend you use <code>condor_submit *-dry-run*</code> to debug your jobs and make sure
 they will work as expected, see <b>useful commands</b> page). Bear in mind that
 submitting untested files and/or jobs may cause a waste of time and resources
 if they fail, and also your priority will be lower in following submissions.
</p>

</div>
</div>
</div>


<div id="outline-container-orgf3f95f8" class="outline-3">
<h3 id="orgf3f95f8"><span class="section-number-3">3.2</span> Creating a Submit File</h3>
<div class="outline-text-3" id="text-3-2">
<p>
As many other languages, HTCondor submit files allow the use of comments,
variable, macros, commands, etc. Here we will describe the most common ones, you
can check the <a href="https://research.cs.wisc.edu/htcondor/manual">official documentation</a> for a complete and detailed
information about submit files and submitting process.
</p>
</div>

<div id="outline-container-org6d57350" class="outline-4">
<h4 id="org6d57350"><span class="section-number-4">3.2.1</span> Comments</h4>
<div class="outline-text-4" id="text-3-2-1">
<p>
HTCondor uses symbol <code>*#*</code> for comments. Everything found after that symbol will
be ignored. Please, do not mix commands and comments in the same line, since it
may produce errors. We recommend you always write commands and comments in
different lines.
</p>

<pre class="example">
# This is a valid comment
A = 4  # This may produce errors when expanding =A=, do not use comments and 
       #  anything else in the same line!
</pre>
</div>
</div>

<div id="outline-container-orgc12ba43" class="outline-4">
<h4 id="orgc12ba43"><span class="section-number-4">3.2.2</span> Variables and macros</h4>
<div class="outline-text-4" id="text-3-2-2">
<p>
There are many predefined variables and macros in HTCondor that you can use, and
you can define your own ones.
</p>

<ul class="org-ul">
<li>To <b>define a variable</b>, just chose a valid name (names are case-insensitive)
and assign a value to it, like <code>N = 4</code>, <code>Name = "example"</code></li>
<li>To <b>get the value</b> of a variable, use next syntax: <code>$(varName)</code>, both <code>$</code>
symbol and parentheses <code>()</code> are mandatory.</li>
<li>You can do <b>basic operations</b> with variables, like <code>B = $(A) + 1</code>, etc. (since
version 8.4.0 is not needed to use the old and complex syntax [@$$[(&#x2026;)]@]
for the operations). To get the expression evaluated, you may need to use
function macros like <code>$INT(B)</code>, <code>$REAL(B)</code>, etc.</li>
<li>There are several special <b>automatic variables</b> defined by HTCondor that will
help you when creating your submit file. The most useful one is <code>*$(Process)*</code>
or <code>$(ProcId)</code>, that will contain the Process ID of each job (if you submit
<code>N</code> jobs, the value of <code>$(Process)</code> will be <code>0</code> for the first job and <code>N-1</code> in
the last job). This variable is like an <b>iteration counter</b> and you can use it
to specify different inputs, outputs, arguments, &#x2026; for each job. There are
some <b>automatic variables</b>, 
like <code>$(Cluster)</code> or <code>$(ClusterId)</code> that stores the ID of each submission,
<code>$(Item)</code>, <code>$(ItemIndex)</code>, <code>$(Step)</code>, <code>$(Row)</code>, etc. (see <b>Example1</b> for
further information).</li>
<li>There are several <b>pre-defined Function Macros</b>. Their syntax is
<code>*$FunctName(varName)*</code> and they can perform some operations on variable
<code>varName</code> like evaluating expressions and type conversions, selecting a value
from a list according an index, getting random numbers, string operations,
filenames processing, setting environment variables, etc. Before creating your
own macros, check if HTCondor has already a <b>pre-defined Function Macro</b> with
the same purpose.</li>
</ul>
</div>
</div>

<div id="outline-container-org66cfeff" class="outline-4">
<h4 id="org66cfeff"><span class="section-number-4">3.2.3</span> Submit commands</h4>
<div class="outline-text-4" id="text-3-2-3">
<p>
You will need to add several HTCondor submit commands in your script file in
order to specify which executable you want to run and where it is located, its
arguments if any, input files, which result files will be generated, etc. There
is a wide set of HTCondor with almost 200 different <b>submit description file
commands</b> to cover many different scenarios. But in most situations you will
only need to specify a few of them (usually about 10-15). Here we will present
the most common ones (commands are case-insensitive):
</p>

<ul class="org-ul">
<li><b>Mandatory commands:</b>
<ul class="org-ul">
<li><code>*executable*</code>: specify where your executable is located (you can use an
absolute path, a relative one to the directory where you do the submission
or to another directory specified with <code>initialdir</code>). You should specify
<b>only the executable</b> and not other things like arguments, etc., there are
specific commands for that. HTCondor will automatically copy the executable
file from your machine to any machine where your job will be executed, so
you do not need to worry about that.</li>
<li><code>*queue*</code>: this command will send your job(s) to the queue, so it should be
the last command in your submit file. In previous versions of HTCondor it
was quite limited, only allowing the number of jobs as argument. But since
version 8.4.0, this command is very powerful and flexible, and you can use
it to specify variables, iterations over other commands, files to be
processed, list of arguments, etc. <b>see complete syntax and examples</b>.</li>
</ul></li>

<li><b>Highly recommended commands:</b>
<ul class="org-ul">
<li><code>*output*</code>: it will copy the standard output printed on the screen
(<code>stdout</code>) of the remote machines when executing your program to the local
file you specify here. Since all the jobs will use the same name, the
filename should include some variable parts that change depending on the job
to avoid overwritten the same file, like <code>$(Process)</code> (and also <code>$(Cluster)</code>
if you do not want that different submissions ruin your output files). Even
if your program does not print any useful results on screen, it is very
recommended you save the screen output to check if there were errors, debug
them if any, etc.</li>
<li><code>*error*</code>: the same as previous command, but for standard error output
(<code>stderr</code>).</li>
<li><code>*log*</code>: it will save a log of your submission that later can be analysed
with HTCondor tools. This is very useful when there is any problem with your
job(s) to find the problem and fix it.  The log should be the same for all
jobs submitted in the same cluster, so you should <b>not</b> use <code>$(Process)</code> in
the filename (but including <code>$(Cluster)</code> is recommended).</li>
<li><code>universe</code>: there are several <b>runtime environments</b> in HTCondor called
''universes'', we will mostly use the one named <code>vanilla</code> since it is the
easiest one. This is the universe by default, so if you miss this command,
your jobs will also go to <code>vanilla</code> universe.</li>
</ul></li>

<li><b>Useful commands when working with inputs and outputs (arguments, files,
keyboard, etc.)</b>:
<ul class="org-ul">
<li><code>*arguments*</code>: it is used to specify options and flags for your executable
file, like when using it in command line.</li>
<li><code>*should_transfer_files*</code>: assign <code>YES</code> to it in order to activate HTCondor
file transfer system (needed when working with files).</li>
<li><code>*when_to_transfer_output*</code>: it will usually have a value of <code>ON_EXIT</code> to
only copy output files when your job is finished, avoiding the copy of
temporary or incomplete files if your job fails or it is moved to another
machine.</li>
<li><code>*transfer_input_files*</code>: it is used to specify where the needed input files
are located. We can use a comma-separated list of files (with absolute or
relative paths, as mentioned in <code>executable</code> command). Local path will be
ignored, and HTCondor will copy all files to the root directory of a virtual
location on the remote machine (your executable will be also copy to the
same place, so input files will be in the same directory). If you specify a
directory in this command, you can choose if you want to copy only the
content of the directory (add a slash "<code>*/*</code>" at the end, for instance
<code>myInputDir*/*</code>) or the directory itself and its content (do not add a
slash).</li>
<li><code>*transfer_output_files*</code>: a comma-separated list of result files to be
copied back to our machine. If this command is omitted, HTCondor will
automatically copy all files that have been created or modified on the
remote machine. Sometimes omitting this command is useful, but other times
our program creates many temporary or useless files and we only want to get
the ones we specify with this command.</li>
<li>More commands for input/output files:
<ul class="org-ul">
<li><code>transfer_output_remaps</code>: it changes the name of the output files when
copying them to your machine. That is useful when your executable
generates result file(s) with the same name, so changing the filename to
include a variable part (like <code>$(Process)</code> and maybe also <code>$(Cluster)</code>)
will avoid overwritten them.</li>
<li><code>initialdir</code>: this command is used to specify the base directory for input
and output files, instead of the directory where the submission was
performed from. If this command include a variable part (like
<code>$(Process)</code>), you can use this command to specify a different base
directory for each job.</li>
<li><code>input</code>: if your program needs some data from keyboard, you can specify a
file or a comma-separated list of files containing it (each end of line in
the file will have the same behaviour as pressing <code>Intro</code> key in the
keyboard, like when using <code>stdin</code> redirection in command line with
<code>*&lt;*</code>). As other similar commands, you can use absolute or relative paths.</li>
<li><code>transfer_executable</code>: by default its value is <code>True</code>, but if it is set to
<code>False</code>, HTCondor will not copy the executable file to the remote
machine(s). This is useful when the executable is a system command or a
program that is installed in all machines, so it is not needed to copy it.</li>
</ul></li>
</ul></li>
</ul>


<ul class="org-ul">
<li><b>Other useful commands:</b>
<ul class="org-ul">
<li><code>request_memory</code>, <code>request_disk</code>: if your program needs a certain amount of
total RAM memory or free disk space, you can use these commands to force
that your jobs will be only executed on machines with at least the requested
memory/free disk space <b>HowTo</b></li>
<li><code>requirements</code>: this is a very useful command if your program has any
special needs. With it you can specify that your job can be only executed on
some machines (or some machines cannot run your program) according to a wide
set of parameters (machine name, operative system and version and a large
etc.) <b>HowTo</b></li>
<li><code>rank</code>: you can specify some values or combination of them (total memory,
free disk space, MIPS, etc.) and HTCondor will choose the best machines for
your jobs according to your specifications, where the higher the value, the
better (this command is used to specify preferences, not requirements)
<b>HowTo</b></li>
<li><code>getenv</code>: if it is set to <code>True</code>, all your environment variables will be
copied at submission time and they will be available when your program is
executed on remote machines (if you do not use this command or it is set to
<code>False</code>, then your jobs will have no environment variables). This is useful
when running some programs that need a special environment, like python,
etc. <b>HowTo</b></li>
<li><code>nice_user</code>: if it is set to <code>True</code>, your jobs will be executed with a fake
user with very low priority, what could be very useful when the queue is
(almost) empty, so you can run your jobs without wasting your real user
priority (you can activate and deactivate this feature when your jobs are
being executed, so you can begin running your jobs as nice user if the queue
is empty and change to normal user when the queue has many other jobs, or
vice versa) <b>HowTo</b></li>
<li><code>concurrency_limits</code>: you can limit the maximum number of your jobs that
could be executed at the same time. You should use this command if your
program needs licences and there are a few of them (like <code>IDL</code>, see also
<b>CondorAndidlvirtualmachine</b>) or if for any reason you cannot use the
HTCondor file transfer system and all your jobs access to the same shared
resource (<code>/scratch</code>, <code>/net/nas</code>, etc.), in order to avoid that too many
concurrent access can stress the network <b>CondorHowTo#howto<sub>limit</sub></b></li>
<li><code>include</code>: since HTCondor v8.4.0, it is possible to <b>include externally
defined submit commands</b> using syntax: <code>*include :* ''&lt;myfile&gt;''</code>. You can
even include the output of external scripts that will be executed at
submission time, adding a pipe symbol after the file: <code>*include :*
    ''&lt;myscript.sh&gt;'' *|*</code></li>
<li>More useful commands:
<ul class="org-ul">
<li><code>environment</code>: this command will allow you to set/unset/change any
environment variable(s) <b>CondorHowTo#howto<sub>env</sub></b></li>
<li><code>priority</code>: if some of your jobs/clusters are more important than others
and you want to execute them first, you can use <code>priority</code> command to
assign them a priority (the higher the value, the higher priority). This
command only have an effect on your own jobs, and it is not related to
users priority <b>CondorHowTo#howto<sub>priority</sub></b>.</li>
<li><code>job_machine_attrs</code>, <code>job_machine_attrs_history_length</code>: use these
commands to reduce the effects of ''black holes'' in HTCondor, what causes
that many of your jobs could fail in a short time
<b>CondorHowTo#howto<sub>failing</sub></b></li>
<li><code>noop_job</code>: you specify a condition and those jobs that evaluate it to
true will not be executed. This is useful when some of your jobs failed
and you want to repeat only the failing jobs, not all of them
<b>CondorHowTo#howto<sub>failing</sub></b></li>
<li><code>+PreCmd</code>, <code>+PreArguments</code>, <code>+PostCmd</code>, <code>+PostArguments</code>: These commands
allow you to run some scripts before and/or after your executable. That is
useful to prepare, convert, decompress, etc. your inputs and outputs if
needed, or debug your executions <b>CondorHowTo#howto<sub>prepostcmd</sub></b></li>
<li><code>notify_user</code>, <code>notification</code>: use these commands if you want to receive a
notification (an email) when your jobs begin, fail and/or finish
<b>CondorHowTo#howto_<sub>notify</sub></b></li>
<li><code>if</code> &#x2026; <code>elif</code> &#x2026; <code>else</code> &#x2026;  <code>endif</code>: since HTCondor version 8.4.0, a
<b>limited conditional semantic</b> is available. You can use it to specify
different commands or options depending on the defined/undefined
variables, HTCondor version, etc.</li>
<li><code>on_exit_hold</code>, <code>on_exit_remove</code>, <code>periodic_hold</code>, <code>periodic_remove</code>,
<code>periodic_release</code>, etc.: you can modify the default behaviour of your
jobs and the associated status. These commands can be used in a wide set
of circumstances. For instance, you can force that jobs that are running
for more than X minutes or hours will be deleted or get a ''on hold''
status (with this you can prevent that failing jobs will be running
forever, since they will be stopped or deleted if they run for a much
longer while than expected) or the opposite, hold those jobs that finish
in an abnormal short time to check later what happened. Or you can also
periodically release your held jobs, to run them on other machines if for
any reason your jobs work fine on some machines, but fail on others
<b>CondorHowTo#howto<sub>failing</sub></b></li>
<li><code>deferrall_time</code>, <code>deferral_window</code>, <code>deferral_prep_time</code>: you can force
your jobs begin at a given date and time. That is useful when the input
data is not ready when submitting and your jobs have to wait till a
certain time <b>CondorHowTo#howto<sub>runintime</sub></b></li>
</ul></li>
</ul></li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orgb218d73" class="outline-3">
<h3 id="orgb218d73"><span class="section-number-3">3.3</span> Templates and examples</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Here you can find basic templates of submit files, you can use them as starting
point and then do the customizations needed for your executions. Check the
examples in following sections for details and explanations.
</p>
</div>

<div id="outline-container-orga2bf2e2" class="outline-4">
<h4 id="orga2bf2e2"><span class="section-number-4">3.3.1</span> Common Template</h4>
<div class="outline-text-4" id="text-3-3-1">
<pre class="example">
######################################################
# HTCondor Submit Description File. COMMON TEMPLATE   
# Next commands should be added to all your submit files   
######################################################
if !defined FNAME
  FNAME = condor_exec
endif
ID      = $(Cluster).$(Process)

output  = $(FNAME).$(ID).out
error   = $(FNAME).$(ID).err
log     = $(FNAME).$(Cluster).log

universe                = vanilla
should_transfer_files   = YES
when_to_transfer_output = ON_EXIT
</pre>

<ul class="org-ul">
<li><p>
<b>Explanation:</b>
</p>

<p>
Let's analyse the common template: 
</p>
<ul class="org-ul">
<li>First block:
<ul class="org-ul">
<li>Here we will define some variables that will be used later. The first of
them is <code>FNAME</code> and first we ask with the <code>if defined</code> condition whether
that variable is not already defined (if so, we will use the previous
value). This variable will contain the base name for the files where
HTCondor will save the information displayed on the screen (<code>stdout</code> and
<code>stderr</code>) and the log file. It is interesting to give a common name to
those files generated by HTCondor so later we can identify and manage them
together. Since all jobs will use the name specified there, we have to
include a variable part that has to be different in each job, in order to
avoid overwriting the files. We recommend you use a combination of
<code>$(Process)</code> (it contains the process ID that is different for each job)
and <code>$(Cluster)</code> (it contains the cluster ID that is different for each
submission), as we have done when defining <code>$(ID)</code>. In this way, different
jobs and different submission will use different filenames and none of
them will be overwritten.</li>
</ul></li>
<li>Second block:
<ul class="org-ul">
<li>With <code>output</code> command we force HTCondor to write in the specified file all
the screen output (<code>stdout</code>) generated by each job. We have used the
variables <code>$(FNAME)</code> and <code>$(ID)</code> defined above.</li>
<li>With <code>error</code> command we manage <code>stderr</code> in the same way we did with
<code>output</code>.</li>
<li>Then we have also specified a HTCondor log file with <code>log</code> command. You
should not use <code>$(Process)</code> in the filename of the log since all jobs
should share the same log.</li>
</ul></li>
<li>Third block:
<ul class="org-ul">
<li><code>universe</code>: there are <b>runtime environments</b>
in HTCondor called ''universes'', we will mostly use the one named
<code>vanilla</code> since it is the easiest one. This is the universe by default, so
if you miss this command, your jobs will go also to <code>vanilla</code> universe.</li>
<li><code>should_transfer_files=YES</code> and <code>when_to_transfer_output=ON_EXIT</code> commands
are used to specify that input files have to be copied to the remote
machines and output files must be copied back to your machine only when
our program is finished. Although these commands are only needed when
working with files, we recommend you always use them unless you are
totally sure you can omit them.</li>
</ul></li>
</ul></li>
</ul>
</div>
</div>


<div id="outline-container-orgf58eb5b" class="outline-4">
<h4 id="orgf58eb5b"><span class="section-number-4">3.3.2</span> Examples when working with input/output files and arguments</h4>
<div class="outline-text-4" id="text-3-3-2">
<p>
Most times you will want to run applications that deal with input and/or output
files. Commonly, the input files will be located on your local machine, but
since your application will be executed on other machine(s), it will be needed
to copy your input files there, and then copy the result files back to your
computer once your program is done. HTCondor have some commands to automatically
do both operations in an easy way, so you do not need to worry about the file
transfers: you just need to specify where your files are and HTCondor will copy
them.
</p>

<p>
<b>Note:</b> All these examples will begin defining a specific variable <code>FNAME</code> that
contains the base name of the files that HTCondor will generate to save the
<code>stdout</code>, <code>stderr</code> and log. Next, the common template explained above with be
included using command <code>include</code> (we assume that the common template filename is
<code>condor_common.tmpl</code>).
</p>
</div>

<div id="outline-container-org9c8f778" class="outline-5">
<h5 id="org9c8f778"><span class="section-number-5">3.3.2.1</span> <b>Example A</b> (arbitrary filenames)</h5>
<div class="outline-text-5" id="text-3-3-2-1">
<p>
Process all input files with extension <code>.in</code> in a given directory with next
program: <code>./myprogram -i inputFile -o outputFile</code>
</p>

<pre class="example">
# Including Common Template
FNAME = exampleA
include : /path/to/condor_common.tmpl

transfer_input_files    = $(mydata)
transfer_output_files   = $Fn(mydata).out

executable    = myprogram
arguments     = "-i $Fnx(mydata) -o $Fn(mydata).out"

queue *mydata* matching files /path/to/inputs/*.in
</pre>

<ul class="org-ul">
<li><p>
<b>Explanation:</b> 
We use <code>transfer_input_files</code> to specify where the needed input files are
located. We can use a comma-separated list of files, but since we do not know
the name of the files, we will use the variable <code>mydata</code> to specify them. That
variable is defined in the last line, with the <code>queue</code> command: there, we choose
to process all files in <code>/path/to/inputs</code> with extension <code>.in</code>. When submitting,
HTCondor will check that directory and it will automatically create a job for
each <code>.in</code> file found there, assigning the complete filename to <code>mydata</code> (in
this way, each job will work with a different file). We have used the <code>matching
  files</code> to specify that we only want files matching the condition, but we can
also select only directories (<code>matching dirs</code>) or both of them (just
<code>matching</code>).
</p>

<p>
With <code>transfer_output_files</code> we set the name of the output files, that is the
same as the input file with <code>.out</code> extension. To remove the old extension we use
the <code>$Fn</code> macro, that is one of the <b>new Function Macros</b>
available since version 8.4.0, used to operate the filename and extract the
path, name without extension, extension, etc.
</p>

<p>
Then we use <code>executable</code> to specify the name of the executable (it can be a
system command, your own application, a script, etc). We can use a absolute path
or a relative one to the directory where we will perform the submission. This
executable will be copied to all remote machines automatically. Finally,
<code>arguments</code> is used to specify the options for the program. We have to employ
again <code>Fpdnxq</code> macros, first <code>Fnx</code> to remove the original path (file we be
copied to the root of a virtual location where HTCondor will run the executable
on the remote machine) and then <code>Fn</code> to remove path and change extension of the
output file.
</p></li>
</ul>
</div>
</div>


<div id="outline-container-orgb5a73e5" class="outline-5">
<h5 id="orgb5a73e5"><span class="section-number-5">3.3.2.2</span> <b>Example B</b> (based on ProcessID, old system before HTCondor v8.4.0)</h5>
<div class="outline-text-5" id="text-3-3-2-2">
<p>
Process 50 input files with consecutive names (from data0.in to data49.out)
using the same program as previous example
</p>

<pre class="example">
# Including Common Template
FNAME = example2
include : /path/to/condor_common.tmpl

transfer_input_files    = /path/to/inputs/data$(Process).in
transfer_output_files   = data$(Process).out

N             = 50
executable    = myprogram
arguments     = "-i data$(Process).in -o data$(Process).out"

queue $(N)
</pre>

<ul class="org-ul">
<li><p>
<b>Explanation:</b>
<code>transfer_input_files</code> command allows a comma-separated list of files or
directories that will be copied to the remote machine. Local path will be
ignored, and HTCondor will copy all files to the root directory of a virtual
location on the remote machine (your executable will be also copy to the same
place, so input files will be in the same directory). If you specify a directory
in this command, you can choose if you want to copy only the content of the
directory (add a slash "<code>*/*</code>" at the end, for instance <code>myInputDir*/*</code>) or the
directory itself and its content (do not add a slash). In this case, each job
will process a different input file, and since they have a consecutive name
beginning from <code>0</code>, we will use HTCondor macro <code>$(Process)</code> to build the proper
name, since the process ID will be <code>0</code> from the first job to <code>N-1</code> for the last
job.
</p>

<p>
With <code>transfer_output_files</code> we specify a comma-separated list of result files
to be copied back to our machine. In this case, we specify just one file, with
the same name as the input file, but with <code>.out</code> extension.
</p>

<p>
Then we define the variable <code>N</code> to specify the number of jobs to be
executed. Our program is set using <code>executable</code> command and with <code>arguments</code>
command we specify all the needed options (here the name of the input and output
file with the corresponding flags).
</p>

<p>
At the end, we send all jobs to the queue with <code>queue</code> command, specifying how
many jobs we want (we have used the variable <code>N</code>). 
</p></li>
</ul>
</div>
</div>


<div id="outline-container-org7628438" class="outline-5">
<h5 id="org7628438"><span class="section-number-5">3.3.2.3</span> <b>Example C</b> (lists of files and arguments written in submit file)</h5>
<div class="outline-text-5" id="text-3-3-2-3">
<p>
Process all arbitrary files and arguments of a given list. Executable is
 <code>myprogram</code> and it needs an input file with extension <code>.dat</code> and some
 arguments. Results will be printed on screen (<code>stdout</code>). 
</p>

<pre class="example">
# Including Common Template
FNAME = exampleC
include : /path/to/condor_common.tmpl

executable    = myprogram

queue transfer_input_files,arguments *from* (
  xray434.dat, -d 345 -p f034
  sunf37.dat,  -d 2   -p f302
  light67.dat, -d 62  -p f473
) 
</pre>

<ul class="org-ul">
<li><b>Explanation:</b></li>
</ul>

<p>
We will use the flexibility of <code>queue</code> command to assign values of a list to
several commands. We must specify which files must be transferred and which
arguments are needed by each file. We specify then <code>transfer_input_files</code> and
<code>arguments</code> commands using the <code>from</code> option, and then we add a list of pairs
''file,argument''.
</p>

<p>
At submission time, HTCondor will iterate over the list and expand the
assignations. For instance, our jobs will have next values:
</p>

<ul class="org-ul">
<li><code>transfer_input_files = xray434.dat, arguments = -d 345 -p f034-</code></li>
<li><code>transfer_input_files = sunf37.dat, arguments = -d 2   -p f302-</code></li>
<li><code>transfer_input_files = light67.dat, arguments = -d 62  -p f473-</code></li>
</ul>

<p>
When using this format you can specify as many commands separated by commas as
needed between <code>queue</code> and <code>from</code>, but check that each line in the list has the
right number of elements also separated by commas.
</p>

<p>
Writing the list of items in the submit file can be a little bit tedious, but it
may be easily done in an external file using scripts. Then you can directly
specify the file. For instance, suppose you have all items in a file named
<code>data.lst</code>, then you can use next <code>queue</code> command: 
<code>queue transfer_input_files,arguments from /path/to/data.lst</code>
</p>
</div>
</div>


<div id="outline-container-org3e86b09" class="outline-5">
<h5 id="org3e86b09"><span class="section-number-5">3.3.2.4</span> Example D (lists of files and arguments in external file)</h5>
<div class="outline-text-5" id="text-3-3-2-4">
<p>
Process arbitrary files and arguments stored in file <code>data.lst</code> (process only
 lines from 28 to 43, both inclusive, with step 5). Executable is <code>myprogram</code> as
 in previous example, but this time it saves the result in a file named
 <code>output.out</code>. 
</p>

<pre class="example">
# Including Common Template
FNAME = exampleD
include : /path/to/condor_common.tmpl

transfer_output_files  = output.out
line                   = $(Row)+1
transfer_output_remaps = "output.out=output$INT(line).out"

executable    = myprogram

queue transfer_input_files,arguments *from* [27:43:5] data.lst
</pre>

<ul class="org-ul">
<li><b>Explanation:</b></li>
</ul>

<p>
This example is similar to the previous one, but this time the list of input
files and arguments is written in a file with the following format:
</p>

<pre class="example">
[input_file1,args1]
[input_file2,args2]
[input_file3,args3]
...
</pre>

<p>
To illustrate the <b>slice</b> feature, we have been asked to process only items
(lines) from 28 to 43 with step 5 (28, 33, 38 and 43), this could be useful when
we want to run only certain experiments. The syntax for the slices is very easy,
the same as Python: <code>[init:end:step]</code>. Since the first index is 0, but we do not
use line 0 but line 1, the <code>init</code> should be 27. Then the <code>end</code> is 43 (it should
be 42, but we need to add 1 because the upper limit is included according to our
example). So we specify the slice using <code>[27:43:5]</code> in the <code>queue</code> command,
between the <code>from</code> clause and the file.
</p>

<p>
We have to be careful with the results. Our program writes them in a file named
<code>output.out</code>. We cannot get all files with the same name because they will be
overwritten, so we need to use <code>transfer_output_remaps</code> to change names when
copying from remote machines to our. We can add the <code>$(Process)</code> variable to the
new name, so all of them will be different, but then it could be a little bit
complicated to identify each result. Instead, we will use another of the
<b>automatic variables</b>, called <code>$(Row)</code>. It stores the number of the row in the
list that is being processed, that is, almost the number of the line: since
<code>$(Row)</code> begins in 0, we need to add 1 to get the line number. We do that in
variable <code>$(line)</code>. Then, HTCondor will process rows 27, 32, 37 and 42, and our
output files will be <code>output28.out</code>, <code>output33.out</code>, <code>output38.out</code> and
<code>output43.out</code>.
</p>
</div>
</div>

<div id="outline-container-org49f8a2c" class="outline-5">
<h5 id="org49f8a2c"><span class="section-number-5">3.3.2.5</span> Example E (<code>stdin</code>, <code>initialdir</code> external scripts and lists)</h5>
<div class="outline-text-5" id="text-3-3-2-5">
<p>
Our program <code>myprogram</code> works with <code>stdin</code> (keyboard is used to specify input
data). We have written that input data in 4 files (<code>dataFeH.in</code>, <code>dataOFe.in</code>,
<code>dataOH.in</code> and <code>dataHe.in</code>) and there is a set of 3 different experiments in
directories (<code>dir000</code>, <code>dir001</code> and <code>dir002</code>). Output files will be generated
with the same name as inputs and extension <code>.out</code> (use <code>-o</code> argument) and they
must be located in the same directory where the respective input file
is. Program also needs all <code>*.tbl</code> files located in <code>/path/to/tables</code>.
</p>

<pre class="example">
# Including Common Template
FNAME = exampleE
include : /path/to/condor_common.tmpl

N            = 3
input        = data$(met).in
initialdir   = /path/to/dir$INT(Step,%03d)
include      : input_tables.sh |
transfer_output_files = data$(met).out

executable   = myprogram
arguments    = "-o data$(met).out"

queue $(N) *met* *in* FeH, OFe, OH, He
</pre>

<ul class="org-ul">
<li><b>Explanation:</b></li>
</ul>

<p>
The key of this example is the <code>queue</code> command in last line. We are using the
clause <code>*in*</code> to specify a list of values. HTCondor will create a job for each
element in the list and the current value will be assigned to the variable <code>met</code>
that we have declared (this variable is optional, you can omit it and use the
automatic variable <code>Item</code>). We have 3 set of experiments, so we need to go over
the list 3 times, that is why we have defined <code>N = 3</code> and we are using <code>$(N)</code> in
the <code>queue</code> command. So, at the end, HTCondor will execute 12 jobs (3 runs * 4
elements in the list): we will use automatic variable <code>$(Step)</code> to get the
number of the present run (0, 1 or 2) and <code>$(met)</code> (or <code>$(Item)</code> if we omit the
variable) to get the value of the current element in the list.
</p>

<p>
<code>input</code> command is used to specify a file that will be used as <code>stdin</code>, using
variable <code>$(met)</code> to get the proper filename. That variable will be also used
when building the name of the output files (<code>transfer_output_files</code> command) and
the arguments (<code>arguments</code> command).
</p>

<p>
We use <code>initialdir</code> to specify a base directory that changes according to the
current job, using the automatic variable <code>$(Step)</code>. HTCondor will use this
directory as base for the relative paths, so it will affect the input and output
files, including the <code>stdout</code>, <code>stderr</code> and log files created by HTCondor (see
common template). We use <code>$INT(Step,%03d)</code> to get a 3-digit number (000, 001
and 002) to build the proper path for each experiment, then HTCondor will go to
the right directory to get the input files and to place later the respective
output files there.
</p>

<p>
Last thing we have to solve is the problem with the required input files (all
<code>*.tbl</code> files located in <code>/path/to/tables</code>). HTCondor does not allow globbing in
<code>transfer_input_files</code>, but instead we can use the new feature of <b>including
external files</b> with <code>include</code> command. This command not only include other
files, but also invoke them if the command finish with a <b>bar</b> <code>*|*</code>. Then we
can easily make a external script to get the list of needed files with linux
command <code>ls</code> and options <code>-m</code> (commas are used to separate elements) and <code>-w</code>
(used to specify the wide of the screen before adding a new line. Since we need
all elements in the same line, we should specify a number big enough). In this
case, our external script <code>input_tables.sh</code> is the following one:
</p>

<pre class="example">
#!/bin/bash
echo "transfer_input_files = `ls -w 400 -m /path/to/tables/*.tbl`"
</pre>
</div>
</div>

<div id="outline-container-org9cecac2" class="outline-5">
<h5 id="org9cecac2"><span class="section-number-5">3.3.2.6</span> Example F (loops)</h5>
<div class="outline-text-5" id="text-3-3-2-6">
<p>
Execute each iteration of a 3-level nested loop using: <code>myprogram -dim1 i -dim2
j -dim3 k = with the following ranges: =i:[0,20)</code>, <code>j:[0,15)</code> and
<code>k:[0,35)</code>. Output will be written on screen, no input files are needed.
</p>

<pre class="example">
# Including Common Template
FNAME = exampleF
include : /path/to/condor_common.tmpl
 
MAX_I = 20
MAX_J = 15
MAX_K = 35

N = $(MAX_I) * $(MAX_J) * $(MAX_K)

I = ( $(Process) / ($(MAX_K)  * $(MAX_J)))
J = (($(Process) /  $(MAX_K)) % $(MAX_J))
K = ( $(Process) %  $(MAX_K))

executable = myprogram
arguments  = "-dim1 $INT(I) -dim2 $INT(J) -dim3 $INT(K)"

queue $(N) 
</pre>

<ul class="org-ul">
<li><b>Explanation:</b></li>
</ul>

<p>
In this example we only need to ''simulate'' a 3 nested loops from a 1-level
loop (we will use <code>$(Process)</code> as main loop counter). The 3-level loop will be
the next ones, and HTCondor will create a job for each iteration:
</p>

<pre class="example">
for (i = 0; i &lt; MAX_I; i++)
  for (j = 0; j &lt; MAX_J; j++)
    for (k = 0; k &lt; MAX_K; k++)
      ./myprogram  -dim1 i -dim2 j -dim3 k
</pre>

<p>
Then we only need to set the limits (<code>MAX_I</code>, <code>MAX_J</code>, <code>MAX_K</code>), the number of
total iterations (<code>N = $(MAX_I) * $(MAX_J) * $(MAX_K)</code>) and use some maths to
get the values of <code>I</code>, <code>J</code> and <code>K</code> according the value of <code>$(Process)</code>, as we
have done above (just a few multiplications, integer divisions and remeinders
are needed). 
</p>

<p>
For a 2-level loop, you can use next code:
</p>

<pre class="example">
I = ($(Process) / $(MAX_J))
J = ($(Process) % $(MAX_J))
</pre>
</div>
</div>

<div id="outline-container-org976ca67" class="outline-5">
<h5 id="org976ca67"><span class="section-number-5">3.3.2.7</span> Example G</h5>
<div class="outline-text-5" id="text-3-3-2-7">
<p>
This example shows the use of several useful commands for specific
conditions. It is also a summary of the <b>CondorHowTo</b>, you can find
further details and explanation about the submit commands there. 
</p>

<ul class="org-ul">
<li>Execute <code>myprogram</code> with argument "=-run =" from 0 to 99 by default.</li>
<li><b>BLOCK A</b>: Execute only on machines with at least 4GB RAM and 2GB of free
disk space. The higher memory and the faster calculations, the better (we can
use KFLOPS to choose the faster machines doing floating point operations, but
since memory and kflops have different units, we need to weight them, for
instance, multiplying memory by 200).</li>
<li><b>BLOCK B</b>: Execute only on machines with Linux Fedora21 or upper and avoid
executing on <code>cata</code>, <code>miel</code> and those with hostname beginning with letter <code>m</code>
or <code>d</code>.</li>
<li><b>BLOCK C</b>: It is needed to run script <code>processData.sh</code> before (argument:
<code>-decompress</code>) and after (argument: <code>-compress</code>) to prepare our data.</li>
<li><b>BLOCK D</b>: Our executable needs the environment variables and variable <code>OUT</code>
has to be set with the argument.</li>
<li><b>BLOCK E</b>: Avoid <b>black holes</b> (when your jobs do not execute correctly on
a machine, and since they finish quickly, that machine is getting most of the
jobs).</li>
<li><b>BLOCK F</b>: Get a notification via email when errors in the job. If the job
finishes before 5 minutes or takes more than 2 hours to be done, there was a
problem: hold it to check later what happened.</li>
<li><b>BLOCK G</b>: Our program needs licenses, so we cannot run more than 20 jobs at
the same time. Execute jobs as <b>nice user</b> to save priority since there are
no other jobs running at this moment.</li>
</ul>

<pre class="example">
# Including Common Template
FNAME = exampleG
include : /path/to/condor_common.tmpl

if !defined N
  N = 100
endif

#BLOCK A
requested_memory = 4 GB
requested_disk   = 2 GB
rank             = (200 * Memory) + KFLOPS

#BLOCK B
letter           = substr(toLower(Target.Machine),0,1)
requirements     = (UtsnameSysname == "Linux") 
        &amp;&amp; (OpSysName == "Fedora") &amp;&amp; (OpSysMajorVer &gt;= 21) 
        &amp;&amp; !stringListMember(UtsnameNodename, "cata,miel")
        &amp;&amp; !stringListMember($(letter), "m,d")


#BLOCK C
transfer_input_data = processData.sh
+PreCmd             = "processData.sh"
+PreArguments       = "-decompress"
+PostCmd            = "processData.sh"
+PostArguments      = "-compress"

#BLOCK D
getenv              = True
environment         = "OUT$(Process)"

#BLOCK E
job_machine_attrs = Machine  
job_machine_attrs_history_length = 5           
requirements = $(requirements) 
      &amp;&amp; (target.machine =!= MachineAttrMachine1)  
      &amp;&amp; (target.machine =!= MachineAttrMachine2)

#BLOCK F
notify_user       = myuser@iac.es
notification      = Error

on_exit_hold = ((CurrentTime - JobStartDate) &lt; (5 * 60)
periodic_hold = ((JobStatus == 2) 
         &amp;&amp; (time() - EnteredCurrentStatus) &gt;  (2  $(HOUR)))

#BLOCK G
concurrency_limits = myuser$(Cluster):50
nice_user = True

executable = myprogram
arguments  = "-run $(Process)"

queue $(N) 
</pre>


<div class="mdframed">
<p>
<b>IMPORTANT</b>: Although your program could use shared locations
(<code>/net/XXXX/scratch</code>, <code>/net/nasX</code>, etc.) to read/write files from any machine so
there is no need to copy files, we highly recommend <b>you always use the HTCondor
file transfer system</b> to avoid network congestion since files will be accessed
locally on the remote machines. Bear in mind that HTCondor can execute hundreds
of your jobs at the same time, and if all of them concurrently access to the
same shared location, network could experience a huge stress and fail. If for
any reason you cannot copy files and you have to use shared locations -you are
using huge files of several GB, etc.-, then contact us before submitting to
adapt your jobs in order to avoid network congestion. 
</p>

</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Ángel de Vicente</p>
<p class="email">Email: <a href="mailto:angel.de.vicente@iac.es">angel.de.vicente@iac.es</a></p>
<p class="date">Created: 2023-02-26 Sun 23:37</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
